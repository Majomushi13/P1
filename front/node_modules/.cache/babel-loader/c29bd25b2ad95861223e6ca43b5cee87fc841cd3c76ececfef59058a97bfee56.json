{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// src/useQuery.ts\nimport { ref as ref3, unref, computed as computed3, watch as watch2, onServerPrefetch, getCurrentInstance as getCurrentInstance2, onBeforeUnmount as onBeforeUnmount2, nextTick, shallowRef } from \"vue-demi\";\nimport { throttle, debounce } from \"throttle-debounce\";\n\n// src/useApolloClient.ts\nimport { hasInjectionContext, inject } from \"vue-demi\";\nvar DefaultApolloClient = Symbol(\"default-apollo-client\");\nvar ApolloClients = Symbol(\"apollo-clients\");\nfunction resolveDefaultClient(providedApolloClients, providedApolloClient) {\n  const resolvedClient = providedApolloClients ? providedApolloClients.default : providedApolloClient != null ? providedApolloClient : void 0;\n  return resolvedClient;\n}\nfunction resolveClientWithId(providedApolloClients, clientId) {\n  if (!providedApolloClients) {\n    throw new Error(`No apolloClients injection found, tried to resolve '${clientId}' clientId`);\n  }\n  return providedApolloClients[clientId];\n}\nfunction useApolloClient(clientId) {\n  let resolveImpl;\n  const savedCurrentClients = currentApolloClients;\n  if (!hasInjectionContext()) {\n    resolveImpl = id => {\n      if (id) {\n        return resolveClientWithId(savedCurrentClients, id);\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default);\n    };\n  } else {\n    const providedApolloClients = inject(ApolloClients, null);\n    const providedApolloClient = inject(DefaultApolloClient, null);\n    resolveImpl = id => {\n      if (id) {\n        const client2 = resolveClientWithId(providedApolloClients, id);\n        if (client2) {\n          return client2;\n        }\n        return resolveClientWithId(savedCurrentClients, id);\n      }\n      const client = resolveDefaultClient(providedApolloClients, providedApolloClient);\n      if (client) {\n        return client;\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default);\n    };\n  }\n  function resolveClient(id = clientId) {\n    const client = resolveImpl(id);\n    if (!client) {\n      throw new Error(`Apollo client with id ${id != null ? id : \"default\"} not found. Use an app.runWithContext() or provideApolloClient() if you are outside of a component setup.`);\n    }\n    return client;\n  }\n  return {\n    resolveClient,\n    get client() {\n      return resolveClient();\n    }\n  };\n}\nvar currentApolloClients = {};\nfunction provideApolloClient(client) {\n  currentApolloClients = {\n    default: client\n  };\n  return function (fn) {\n    const result = fn();\n    currentApolloClients = {};\n    return result;\n  };\n}\nfunction provideApolloClients(clients) {\n  currentApolloClients = clients;\n  return function (fn) {\n    const result = fn();\n    currentApolloClients = {};\n    return result;\n  };\n}\n\n// src/util/paramToRef.ts\nimport { isRef, computed, ref } from \"vue-demi\";\nfunction paramToRef(param) {\n  if (isRef(param)) {\n    return param;\n  } else if (typeof param === \"function\") {\n    return computed(param);\n  } else {\n    return ref(param);\n  }\n}\n\n// src/util/paramToReactive.ts\nimport { isRef as isRef2, reactive, computed as computed2 } from \"vue-demi\";\nfunction paramToReactive(param) {\n  if (isRef2(param)) {\n    return param;\n  } else if (typeof param === \"function\") {\n    return computed2(param);\n  } else if (param) {\n    return reactive(param);\n  } else {\n    return param;\n  }\n}\n\n// src/util/useEventHook.ts\nfunction useEventHook() {\n  const fns = [];\n  function on(fn) {\n    fns.push(fn);\n    return {\n      off: () => off(fn)\n    };\n  }\n  function off(fn) {\n    const index = fns.indexOf(fn);\n    if (index !== -1) {\n      fns.splice(index, 1);\n    }\n  }\n  function trigger(...params) {\n    for (const fn of fns) {\n      fn(...params);\n    }\n  }\n  function getCount() {\n    return fns.length;\n  }\n  return {\n    on,\n    off,\n    trigger,\n    getCount\n  };\n}\n\n// src/util/loadingTracking.ts\nimport { watch, onUnmounted, ref as ref2, getCurrentInstance, onBeforeUnmount } from \"vue-demi\";\n\n// src/util/env.ts\nvar isServer = typeof window === \"undefined\";\n\n// src/util/loadingTracking.ts\nvar globalTracking = {\n  queries: ref2(0),\n  mutations: ref2(0),\n  subscriptions: ref2(0),\n  components: new Map()\n};\nfunction getCurrentTracking() {\n  const vm = getCurrentInstance();\n  if (!vm) {\n    return {};\n  }\n  let tracking;\n  if (!globalTracking.components.has(vm)) {\n    globalTracking.components.set(vm, tracking = {\n      queries: ref2(0),\n      mutations: ref2(0),\n      subscriptions: ref2(0)\n    });\n    onUnmounted(() => {\n      globalTracking.components.delete(vm);\n    });\n  } else {\n    tracking = globalTracking.components.get(vm);\n  }\n  return {\n    tracking\n  };\n}\nfunction track(loading, type) {\n  if (isServer) return;\n  const {\n    tracking\n  } = getCurrentTracking();\n  watch(loading, (value, oldValue) => {\n    if (oldValue != null && value !== oldValue) {\n      const mod = value ? 1 : -1;\n      if (tracking) tracking[type].value += mod;\n      globalTracking[type].value += mod;\n    }\n  }, {\n    immediate: true\n  });\n  onBeforeUnmount(() => {\n    if (loading.value) {\n      if (tracking) tracking[type].value--;\n      globalTracking[type].value--;\n    }\n  });\n}\nfunction trackQuery(loading) {\n  track(loading, \"queries\");\n}\nfunction trackMutation(loading) {\n  track(loading, \"mutations\");\n}\nfunction trackSubscription(loading) {\n  track(loading, \"subscriptions\");\n}\n\n// src/util/toApolloError.ts\nimport { ApolloError, isApolloError } from \"@apollo/client/core/index.js\";\nfunction toApolloError(error) {\n  if (!(error instanceof Error)) {\n    return new ApolloError({\n      networkError: Object.assign(new Error(), {\n        originalError: error\n      }),\n      errorMessage: String(error)\n    });\n  }\n  if (isApolloError(error)) {\n    return error;\n  }\n  return new ApolloError({\n    networkError: error,\n    errorMessage: error.message\n  });\n}\nfunction resultErrorsToApolloError(errors) {\n  return new ApolloError({\n    graphQLErrors: errors,\n    errorMessage: `GraphQL response contains errors: ${errors.map(e => e.message).join(\" | \")}`\n  });\n}\n\n// src/useQuery.ts\nfunction useQuery(document, variables, options) {\n  return useQueryImpl(document, variables, options);\n}\nfunction useQueryImpl(document, variables, options = {}, lazy = false) {\n  var _a;\n  const vm = getCurrentInstance2();\n  const currentOptions = ref3();\n  const documentRef = paramToRef(document);\n  const variablesRef = paramToRef(variables);\n  const optionsRef = paramToReactive(options);\n  const result = shallowRef();\n  const resultEvent = useEventHook();\n  const error = shallowRef(null);\n  const errorEvent = useEventHook();\n  const loading = ref3(false);\n  vm && trackQuery(loading);\n  const networkStatus = ref3();\n  let firstResolve;\n  let firstResolveTriggered = false;\n  let firstReject;\n  let firstRejectError;\n  const tryFirstResolve = () => {\n    firstResolveTriggered = true;\n    if (firstResolve) firstResolve();\n  };\n  const tryFirstReject = apolloError => {\n    firstRejectError = apolloError;\n    if (firstReject) firstReject(apolloError);\n  };\n  const resetFirstResolveReject = () => {\n    firstResolve = void 0;\n    firstReject = void 0;\n    firstResolveTriggered = false;\n    firstRejectError = void 0;\n  };\n  vm && ((_a = onServerPrefetch) == null ? void 0 : _a(() => {\n    var _a2;\n    if (!isEnabled.value || isServer && ((_a2 = currentOptions.value) == null ? void 0 : _a2.prefetch) === false) return;\n    return new Promise((resolve, reject) => {\n      firstResolve = () => {\n        resetFirstResolveReject();\n        resolve();\n      };\n      firstReject = apolloError => {\n        resetFirstResolveReject();\n        reject(apolloError);\n      };\n      if (firstResolveTriggered) {\n        firstResolve();\n      } else if (firstRejectError) {\n        firstReject(firstRejectError);\n      }\n    }).finally(stop);\n  }));\n  const {\n    resolveClient\n  } = useApolloClient();\n  function getClient() {\n    var _a2;\n    return resolveClient((_a2 = currentOptions.value) == null ? void 0 : _a2.clientId);\n  }\n  const query = shallowRef();\n  let observer;\n  let started = false;\n  let ignoreNextResult = false;\n  let firstStart = true;\n  function start() {\n    var _a2, _b, _c, _d, _e;\n    if (started || !isEnabled.value || isServer && ((_a2 = currentOptions.value) == null ? void 0 : _a2.prefetch) === false || !currentDocument) {\n      tryFirstResolve();\n      return;\n    }\n    if (isServer) {\n      applyDocument(documentRef.value);\n      applyVariables(variablesRef.value);\n      applyOptions(unref(optionsRef));\n    }\n    started = true;\n    error.value = null;\n    loading.value = true;\n    const client = getClient();\n    query.value = client.watchQuery({\n      query: currentDocument,\n      variables: currentVariables != null ? currentVariables : {},\n      ...currentOptions.value,\n      ...(isServer && ((_b = currentOptions.value) == null ? void 0 : _b.fetchPolicy) !== \"no-cache\" ? {\n        fetchPolicy: \"network-only\"\n      } : {})\n    });\n    startQuerySubscription();\n    if (!isServer && (firstStart || !((_c = currentOptions.value) == null ? void 0 : _c.keepPreviousResult)) && (((_d = currentOptions.value) == null ? void 0 : _d.fetchPolicy) !== \"no-cache\" || currentOptions.value.notifyOnNetworkStatusChange)) {\n      const currentResult = query.value.getCurrentResult(false);\n      if (!currentResult.loading || currentResult.partial || ((_e = currentOptions.value) == null ? void 0 : _e.notifyOnNetworkStatusChange)) {\n        onNextResult(currentResult);\n        ignoreNextResult = !currentResult.loading;\n      } else if (currentResult.error) {\n        onError(currentResult.error);\n        ignoreNextResult = true;\n      }\n    }\n    if (!isServer) {\n      for (const item of subscribeToMoreItems) {\n        addSubscribeToMore(item);\n      }\n    }\n    firstStart = false;\n  }\n  function startQuerySubscription() {\n    if (observer && !observer.closed) return;\n    if (!query.value) return;\n    ignoreNextResult = false;\n    observer = query.value.subscribe({\n      next: onNextResult,\n      error: onError\n    });\n  }\n  function getErrorPolicy() {\n    var _a2, _b, _c, _d;\n    const client = resolveClient((_a2 = currentOptions.value) == null ? void 0 : _a2.clientId);\n    return ((_b = currentOptions.value) == null ? void 0 : _b.errorPolicy) || ((_d = (_c = client.defaultOptions) == null ? void 0 : _c.watchQuery) == null ? void 0 : _d.errorPolicy);\n  }\n  function onNextResult(queryResult) {\n    var _a2;\n    if (ignoreNextResult) {\n      ignoreNextResult = false;\n      return;\n    }\n    error.value = null;\n    processNextResult(queryResult);\n    const errorPolicy = getErrorPolicy();\n    if (errorPolicy && errorPolicy === \"all\" && !queryResult.error && ((_a2 = queryResult.errors) == null ? void 0 : _a2.length)) {\n      processError(resultErrorsToApolloError(queryResult.errors));\n    }\n    tryFirstResolve();\n  }\n  function processNextResult(queryResult) {\n    result.value = queryResult.data && Object.keys(queryResult.data).length === 0 ? void 0 : queryResult.data;\n    loading.value = queryResult.loading;\n    networkStatus.value = queryResult.networkStatus;\n    nextTick(() => {\n      resultEvent.trigger(queryResult, {\n        client: getClient()\n      });\n    });\n  }\n  function onError(queryError) {\n    if (ignoreNextResult) {\n      ignoreNextResult = false;\n      return;\n    }\n    const apolloError = toApolloError(queryError);\n    const errorPolicy = getErrorPolicy();\n    if (errorPolicy && errorPolicy !== \"none\") {\n      processNextResult(query.value.getCurrentResult());\n    }\n    processError(apolloError);\n    tryFirstReject(apolloError);\n    resubscribeToQuery();\n  }\n  function processError(apolloError) {\n    error.value = apolloError;\n    loading.value = false;\n    networkStatus.value = 8;\n    nextTick(() => {\n      errorEvent.trigger(apolloError, {\n        client: getClient()\n      });\n    });\n  }\n  function resubscribeToQuery() {\n    if (!query.value) return;\n    const lastError = query.value.getLastError();\n    const lastResult = query.value.getLastResult();\n    query.value.resetLastResults();\n    startQuerySubscription();\n    Object.assign(query.value, {\n      lastError,\n      lastResult\n    });\n  }\n  let onStopHandlers = [];\n  function stop() {\n    tryFirstResolve();\n    if (!started) return;\n    started = false;\n    loading.value = false;\n    onStopHandlers.forEach(handler => handler());\n    onStopHandlers = [];\n    if (query.value) {\n      query.value.stopPolling();\n      query.value = null;\n    }\n    if (observer) {\n      observer.unsubscribe();\n      observer = void 0;\n    }\n  }\n  let restarting = false;\n  function baseRestart() {\n    if (!started || restarting) return;\n    restarting = true;\n    nextTick(() => {\n      if (started) {\n        stop();\n        start();\n      }\n      restarting = false;\n    });\n  }\n  let debouncedRestart;\n  let isRestartDebounceSetup = false;\n  function updateRestartFn() {\n    var _a2, _b;\n    if (!currentOptions.value) {\n      debouncedRestart = baseRestart;\n    } else {\n      if ((_a2 = currentOptions.value) == null ? void 0 : _a2.throttle) {\n        debouncedRestart = throttle(currentOptions.value.throttle, baseRestart);\n      } else if ((_b = currentOptions.value) == null ? void 0 : _b.debounce) {\n        debouncedRestart = debounce(currentOptions.value.debounce, baseRestart);\n      } else {\n        debouncedRestart = baseRestart;\n      }\n      isRestartDebounceSetup = true;\n    }\n  }\n  function restart() {\n    if (!started || restarting) return;\n    if (!isRestartDebounceSetup) updateRestartFn();\n    debouncedRestart();\n  }\n  let currentDocument = documentRef.value;\n  const forceDisabled = ref3(lazy);\n  const enabledOption = computed3(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled);\n  const isEnabled = computed3(() => enabledOption.value && !forceDisabled.value && !!documentRef.value);\n  watch2(() => unref(optionsRef), applyOptions, {\n    deep: true,\n    immediate: true\n  });\n  function applyOptions(value) {\n    if (currentOptions.value && (currentOptions.value.throttle !== value.throttle || currentOptions.value.debounce !== value.debounce)) {\n      updateRestartFn();\n    }\n    currentOptions.value = value;\n    restart();\n  }\n  watch2(documentRef, applyDocument);\n  function applyDocument(value) {\n    currentDocument = value;\n    restart();\n  }\n  let currentVariables;\n  let currentVariablesSerialized;\n  watch2(() => {\n    if (isEnabled.value) {\n      return variablesRef.value;\n    } else {\n      return void 0;\n    }\n  }, applyVariables, {\n    deep: true,\n    immediate: true\n  });\n  function applyVariables(value) {\n    const serialized = JSON.stringify([value, isEnabled.value]);\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value;\n      restart();\n    }\n    currentVariablesSerialized = serialized;\n  }\n  function refetch(variables2 = void 0) {\n    if (query.value) {\n      if (variables2) {\n        currentVariables = variables2;\n      }\n      error.value = null;\n      loading.value = true;\n      return query.value.refetch(variables2).then(refetchResult => {\n        var _a2;\n        const currentResult = (_a2 = query.value) == null ? void 0 : _a2.getCurrentResult();\n        currentResult && processNextResult(currentResult);\n        return refetchResult;\n      });\n    }\n  }\n  function fetchMore(options2) {\n    if (query.value) {\n      error.value = null;\n      loading.value = true;\n      return query.value.fetchMore(options2).then(fetchMoreResult => {\n        var _a2;\n        const currentResult = (_a2 = query.value) == null ? void 0 : _a2.getCurrentResult();\n        currentResult && processNextResult(currentResult);\n        return fetchMoreResult;\n      });\n    }\n  }\n  const subscribeToMoreItems = [];\n  function subscribeToMore(options2) {\n    if (isServer) return;\n    const optionsRef2 = paramToRef(options2);\n    watch2(optionsRef2, (value, oldValue, onCleanup) => {\n      const index = subscribeToMoreItems.findIndex(item2 => item2.options === oldValue);\n      if (index !== -1) {\n        subscribeToMoreItems.splice(index, 1);\n      }\n      const item = {\n        options: value,\n        unsubscribeFns: []\n      };\n      subscribeToMoreItems.push(item);\n      addSubscribeToMore(item);\n      onCleanup(() => {\n        item.unsubscribeFns.forEach(fn => fn());\n        item.unsubscribeFns = [];\n      });\n    }, {\n      immediate: true\n    });\n  }\n  function addSubscribeToMore(item) {\n    if (!started) return;\n    if (!query.value) {\n      throw new Error(\"Query is not defined\");\n    }\n    const unsubscribe = query.value.subscribeToMore(item.options);\n    onStopHandlers.push(unsubscribe);\n    item.unsubscribeFns.push(unsubscribe);\n  }\n  watch2(isEnabled, value => {\n    if (value) {\n      nextTick(() => {\n        start();\n      });\n    } else {\n      stop();\n    }\n  });\n  if (isEnabled.value) {\n    start();\n  }\n  vm && onBeforeUnmount2(() => {\n    stop();\n    subscribeToMoreItems.length = 0;\n  });\n  return {\n    result,\n    loading,\n    networkStatus,\n    error,\n    start,\n    stop,\n    restart,\n    forceDisabled,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    query,\n    refetch,\n    fetchMore,\n    subscribeToMore,\n    onResult: resultEvent.on,\n    onError: errorEvent.on\n  };\n}\n\n// src/useLazyQuery.ts\nimport { isRef as isRef3 } from \"vue-demi\";\nfunction useLazyQuery(document, variables, options) {\n  const query = useQueryImpl(document, variables, options, true);\n  function load(document2, variables2, options2) {\n    if (document2) {\n      query.document.value = document2;\n    }\n    if (variables2) {\n      query.variables.value = variables2;\n    }\n    if (options2) {\n      Object.assign(isRef3(query.options) ? query.options.value : query.options, options2);\n    }\n    const isFirstRun = query.forceDisabled.value;\n    if (isFirstRun) {\n      query.forceDisabled.value = false;\n      if (isServer) {\n        query.start();\n      }\n      return new Promise((resolve, reject) => {\n        const {\n          off: offResult\n        } = query.onResult(result => {\n          if (!result.loading) {\n            resolve(result.data);\n            offResult();\n            offError();\n          }\n        });\n        const {\n          off: offError\n        } = query.onError(error => {\n          reject(error);\n          offResult();\n          offError();\n        });\n      });\n    } else {\n      return false;\n    }\n  }\n  return {\n    ...query,\n    load\n  };\n}\n\n// src/useMutation.ts\nimport { ref as ref4, onBeforeUnmount as onBeforeUnmount3, isRef as isRef4, getCurrentInstance as getCurrentInstance3, shallowRef as shallowRef2 } from \"vue-demi\";\nfunction useMutation(document, options = {}) {\n  const vm = getCurrentInstance3();\n  const loading = ref4(false);\n  vm && trackMutation(loading);\n  const error = shallowRef2(null);\n  const called = ref4(false);\n  const doneEvent = useEventHook();\n  const errorEvent = useEventHook();\n  const {\n    resolveClient\n  } = useApolloClient();\n  async function mutate(variables, overrideOptions = {}) {\n    let currentDocument;\n    if (typeof document === \"function\") {\n      currentDocument = document();\n    } else if (isRef4(document)) {\n      currentDocument = document.value;\n    } else {\n      currentDocument = document;\n    }\n    let currentOptions;\n    if (typeof options === \"function\") {\n      currentOptions = options();\n    } else if (isRef4(options)) {\n      currentOptions = options.value;\n    } else {\n      currentOptions = options;\n    }\n    const client = resolveClient(currentOptions.clientId);\n    error.value = null;\n    loading.value = true;\n    called.value = true;\n    try {\n      const result = await client.mutate({\n        mutation: currentDocument,\n        ...currentOptions,\n        ...overrideOptions,\n        variables: (variables != null ? variables : currentOptions.variables) ? {\n          ...currentOptions.variables,\n          ...variables\n        } : void 0\n      });\n      loading.value = false;\n      doneEvent.trigger(result, {\n        client\n      });\n      return result;\n    } catch (e) {\n      const apolloError = toApolloError(e);\n      error.value = apolloError;\n      loading.value = false;\n      errorEvent.trigger(apolloError, {\n        client\n      });\n      if (currentOptions.throws === \"always\" || currentOptions.throws !== \"never\" && !errorEvent.getCount()) {\n        throw apolloError;\n      }\n    }\n    return null;\n  }\n  vm && onBeforeUnmount3(() => {\n    loading.value = false;\n  });\n  return {\n    mutate,\n    loading,\n    error,\n    called,\n    onDone: doneEvent.on,\n    onError: errorEvent.on\n  };\n}\n\n// src/useSubscription.ts\nimport { ref as ref5, watch as watch3, isRef as isRef5, computed as computed4, getCurrentInstance as getCurrentInstance4, onBeforeUnmount as onBeforeUnmount4, nextTick as nextTick2, shallowRef as shallowRef3 } from \"vue-demi\";\nimport { throttle as throttle2, debounce as debounce2 } from \"throttle-debounce\";\nfunction useSubscription(document, variables = void 0, options = {}) {\n  const vm = getCurrentInstance4();\n  const documentRef = paramToRef(document);\n  const variablesRef = paramToRef(variables);\n  const optionsRef = paramToReactive(options);\n  const result = shallowRef3();\n  const resultEvent = useEventHook();\n  const error = shallowRef3(null);\n  const errorEvent = useEventHook();\n  const loading = ref5(false);\n  vm && trackSubscription(loading);\n  const {\n    resolveClient\n  } = useApolloClient();\n  const subscription = ref5(null);\n  let observer = null;\n  let started = false;\n  function getClient() {\n    var _a;\n    return resolveClient((_a = currentOptions.value) == null ? void 0 : _a.clientId);\n  }\n  function start() {\n    if (started || !isEnabled.value || isServer) return;\n    started = true;\n    loading.value = true;\n    const client = getClient();\n    subscription.value = client.subscribe({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value\n    });\n    observer = subscription.value.subscribe({\n      next: onNextResult,\n      error: onError\n    });\n  }\n  function onNextResult(fetchResult) {\n    result.value = fetchResult.data;\n    loading.value = false;\n    resultEvent.trigger(fetchResult, {\n      client: getClient()\n    });\n  }\n  function onError(fetchError) {\n    const apolloError = toApolloError(fetchError);\n    error.value = apolloError;\n    loading.value = false;\n    errorEvent.trigger(apolloError, {\n      client: getClient()\n    });\n  }\n  function stop() {\n    if (!started) return;\n    started = false;\n    loading.value = false;\n    if (subscription.value) {\n      subscription.value = null;\n    }\n    if (observer) {\n      observer.unsubscribe();\n      observer = null;\n    }\n  }\n  let restarting = false;\n  function baseRestart() {\n    if (!started || restarting) return;\n    restarting = true;\n    nextTick2(() => {\n      if (started) {\n        stop();\n        start();\n      }\n      restarting = false;\n    });\n  }\n  let debouncedRestart;\n  function updateRestartFn() {\n    var _a, _b;\n    if ((_a = currentOptions.value) == null ? void 0 : _a.throttle) {\n      debouncedRestart = throttle2(currentOptions.value.throttle, baseRestart);\n    } else if ((_b = currentOptions.value) == null ? void 0 : _b.debounce) {\n      debouncedRestart = debounce2(currentOptions.value.debounce, baseRestart);\n    } else {\n      debouncedRestart = baseRestart;\n    }\n  }\n  function restart() {\n    if (!debouncedRestart) updateRestartFn();\n    debouncedRestart();\n  }\n  const currentOptions = ref5();\n  watch3(() => isRef5(optionsRef) ? optionsRef.value : optionsRef, value => {\n    if (currentOptions.value && (currentOptions.value.throttle !== value.throttle || currentOptions.value.debounce !== value.debounce)) {\n      updateRestartFn();\n    }\n    currentOptions.value = value;\n    restart();\n  }, {\n    deep: true,\n    immediate: true\n  });\n  let currentDocument;\n  watch3(documentRef, value => {\n    currentDocument = value;\n    restart();\n  }, {\n    immediate: true\n  });\n  let currentVariables;\n  let currentVariablesSerialized;\n  watch3(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value);\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value;\n      restart();\n    }\n    currentVariablesSerialized = serialized;\n  }, {\n    deep: true,\n    immediate: true\n  });\n  const enabledOption = computed4(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled);\n  const isEnabled = enabledOption;\n  watch3(isEnabled, value => {\n    if (value) {\n      start();\n    } else {\n      stop();\n    }\n  }, {\n    immediate: true\n  });\n  vm && onBeforeUnmount4(stop);\n  return {\n    result,\n    loading,\n    error,\n    start,\n    stop,\n    restart,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    subscription,\n    onResult: resultEvent.on,\n    onError: errorEvent.on\n  };\n}\n\n// src/useResult.ts\nimport { computed as computed5 } from \"vue-demi\";\nfunction useResult(result, defaultValue, pick) {\n  console.warn(`'useResult' is deprecated and will be removed soon. Please use 'computed' instead.\nBefore:\nconst items = useResult(result, [], data => data.someField.myItems)\nAfter:\nconst items = computed(() => result.value?.someField.myItems ?? [])`);\n  return computed5(() => {\n    const value = result.value;\n    if (value) {\n      if (pick) {\n        try {\n          return pick(value);\n        } catch (e) {}\n      } else {\n        const keys = Object.keys(value);\n        if (keys.length === 1) {\n          return value[keys[0]];\n        } else {\n          return value;\n        }\n      }\n    }\n    return defaultValue;\n  });\n}\n\n// src/useLoading.ts\nimport { computed as computed6 } from \"vue-demi\";\nfunction useQueryLoading() {\n  const {\n    tracking\n  } = getCurrentTracking();\n  if (!tracking) throw new Error(\"useQueryLoading must be called inside a setup function.\");\n  return computed6(() => tracking.queries.value > 0);\n}\nfunction useMutationLoading() {\n  const {\n    tracking\n  } = getCurrentTracking();\n  if (!tracking) throw new Error(\"useMutationLoading must be called inside a setup function.\");\n  return computed6(() => tracking.mutations.value > 0);\n}\nfunction useSubscriptionLoading() {\n  const {\n    tracking\n  } = getCurrentTracking();\n  if (!tracking) throw new Error(\"useSubscriptionLoading must be called inside a setup function.\");\n  return computed6(() => tracking.subscriptions.value > 0);\n}\nfunction useGlobalQueryLoading() {\n  return computed6(() => globalTracking.queries.value > 0);\n}\nfunction useGlobalMutationLoading() {\n  return computed6(() => globalTracking.mutations.value > 0);\n}\nfunction useGlobalSubscriptionLoading() {\n  return computed6(() => globalTracking.subscriptions.value > 0);\n}\nexport { ApolloClients, DefaultApolloClient, provideApolloClient, provideApolloClients, useApolloClient, useGlobalMutationLoading, useGlobalQueryLoading, useGlobalSubscriptionLoading, useLazyQuery, useMutation, useMutationLoading, useQuery, useQueryLoading, useResult, useSubscription, useSubscriptionLoading };","map":{"version":3,"names":["ref","ref3","unref","computed","computed3","watch","watch2","onServerPrefetch","getCurrentInstance","getCurrentInstance2","onBeforeUnmount","onBeforeUnmount2","nextTick","shallowRef","throttle","debounce","hasInjectionContext","inject","DefaultApolloClient","Symbol","ApolloClients","resolveDefaultClient","providedApolloClients","providedApolloClient","resolvedClient","default","resolveClientWithId","clientId","Error","useApolloClient","resolveImpl","savedCurrentClients","currentApolloClients","id","client2","client","resolveClient","provideApolloClient","fn","result","provideApolloClients","clients","isRef","paramToRef","param","isRef2","reactive","computed2","paramToReactive","useEventHook","fns","on","push","off","index","indexOf","splice","trigger","params","getCount","length","onUnmounted","ref2","isServer","window","globalTracking","queries","mutations","subscriptions","components","Map","getCurrentTracking","vm","tracking","has","set","delete","get","track","loading","type","value","oldValue","mod","immediate","trackQuery","trackMutation","trackSubscription","ApolloError","isApolloError","toApolloError","error","networkError","Object","assign","originalError","errorMessage","String","message","resultErrorsToApolloError","errors","graphQLErrors","map","e","join","useQuery","document","variables","options","useQueryImpl","lazy","_a","currentOptions","documentRef","variablesRef","optionsRef","resultEvent","errorEvent","networkStatus","firstResolve","firstResolveTriggered","firstReject","firstRejectError","tryFirstResolve","tryFirstReject","apolloError","resetFirstResolveReject","_a2","isEnabled","prefetch","Promise","resolve","reject","finally","stop","getClient","query","observer","started","ignoreNextResult","firstStart","start","_b","_c","_d","_e","currentDocument","applyDocument","applyVariables","applyOptions","watchQuery","currentVariables","fetchPolicy","startQuerySubscription","keepPreviousResult","notifyOnNetworkStatusChange","currentResult","getCurrentResult","partial","onNextResult","onError","item","subscribeToMoreItems","addSubscribeToMore","closed","subscribe","next","getErrorPolicy","errorPolicy","defaultOptions","queryResult","processNextResult","processError","data","keys","queryError","resubscribeToQuery","lastError","getLastError","lastResult","getLastResult","resetLastResults","onStopHandlers","forEach","handler","stopPolling","unsubscribe","restarting","baseRestart","debouncedRestart","isRestartDebounceSetup","updateRestartFn","restart","forceDisabled","enabledOption","enabled","deep","currentVariablesSerialized","serialized","JSON","stringify","refetch","variables2","then","refetchResult","fetchMore","options2","fetchMoreResult","subscribeToMore","optionsRef2","onCleanup","findIndex","item2","unsubscribeFns","onResult","isRef3","useLazyQuery","load","document2","isFirstRun","offResult","offError","ref4","onBeforeUnmount3","isRef4","getCurrentInstance3","shallowRef2","useMutation","called","doneEvent","mutate","overrideOptions","mutation","throws","onDone","ref5","watch3","isRef5","computed4","getCurrentInstance4","onBeforeUnmount4","nextTick2","shallowRef3","throttle2","debounce2","useSubscription","subscription","fetchResult","fetchError","computed5","useResult","defaultValue","pick","console","warn","computed6","useQueryLoading","useMutationLoading","useSubscriptionLoading","useGlobalQueryLoading","useGlobalMutationLoading","useGlobalSubscriptionLoading"],"sources":["../src/useQuery.ts","../src/useApolloClient.ts","../src/util/paramToRef.ts","../src/util/paramToReactive.ts","../src/util/useEventHook.ts","../src/util/loadingTracking.ts","../src/util/env.ts","../src/util/toApolloError.ts","../src/useLazyQuery.ts","../src/useMutation.ts","../src/useSubscription.ts","../src/useResult.ts","../src/useLoading.ts"],"sourcesContent":["import {\n  ref,\n  Ref,\n  unref,\n  computed,\n  watch,\n  onServerPrefetch,\n  getCurrentInstance,\n  onBeforeUnmount,\n  nextTick,\n  shallowRef,\n} from 'vue-demi'\nimport { DocumentNode } from 'graphql'\nimport type {\n  OperationVariables,\n  WatchQueryOptions,\n  ObservableQuery,\n  ApolloQueryResult,\n  SubscribeToMoreOptions,\n  FetchMoreQueryOptions,\n  FetchMoreOptions,\n  ObservableSubscription,\n  TypedDocumentNode,\n  ApolloError,\n  ApolloClient,\n} from '@apollo/client/core/index.js'\nimport { throttle, debounce } from 'throttle-debounce'\nimport { useApolloClient } from './useApolloClient'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { paramToRef } from './util/paramToRef'\nimport { paramToReactive } from './util/paramToReactive'\nimport { useEventHook } from './util/useEventHook'\nimport { trackQuery } from './util/loadingTracking'\nimport { resultErrorsToApolloError, toApolloError } from './util/toApolloError'\nimport { isServer } from './util/env'\n\nimport type { CurrentInstance } from './util/types'\n\nexport interface UseQueryOptions<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TResult = any,\n  TVariables extends OperationVariables = OperationVariables\n> extends Omit<WatchQueryOptions<TVariables>, 'query' | 'variables'> {\n  clientId?: string\n  enabled?: boolean | Ref<boolean>\n  throttle?: number\n  debounce?: number\n  prefetch?: boolean\n  keepPreviousResult?: boolean\n}\n\ninterface SubscribeToMoreItem {\n  options: any\n  unsubscribeFns: (() => void)[]\n}\n\n// Parameters\nexport type DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode | null | undefined> | ReactiveFunction<DocumentNode | null | undefined> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables> | null | undefined> | ReactiveFunction<TypedDocumentNode<TResult, TVariables> | null | undefined>\nexport type VariablesParameter<TVariables> = TVariables | Ref<TVariables> | ReactiveFunction<TVariables>\nexport type OptionsParameter<TResult, TVariables extends OperationVariables> = UseQueryOptions<TResult, TVariables> | Ref<UseQueryOptions<TResult, TVariables>> | ReactiveFunction<UseQueryOptions<TResult, TVariables>>\n\nexport interface OnResultContext {\n  client: ApolloClient<any>\n}\n\nexport interface OnErrorContext {\n  client: ApolloClient<any>\n}\n\n// Return\nexport interface UseQueryReturn<TResult, TVariables extends OperationVariables> {\n  result: Ref<TResult | undefined>\n  loading: Ref<boolean>\n  networkStatus: Ref<number | undefined>\n  error: Ref<ApolloError | null>\n  start: () => void\n  stop: () => void\n  restart: () => void\n  forceDisabled: Ref<boolean>\n  document: Ref<DocumentNode | null | undefined>\n  variables: Ref<TVariables | undefined>\n  options: UseQueryOptions<TResult, TVariables> | Ref<UseQueryOptions<TResult, TVariables>>\n  query: Ref<ObservableQuery<TResult, TVariables> | null | undefined>\n  refetch: (variables?: TVariables) => Promise<ApolloQueryResult<TResult>> | undefined\n  fetchMore: (options: FetchMoreQueryOptions<TVariables, TResult> & FetchMoreOptions<TResult, TVariables>) => Promise<ApolloQueryResult<TResult>> | undefined\n  subscribeToMore: <TSubscriptionVariables = OperationVariables, TSubscriptionData = TResult>(options: SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData> | Ref<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>> | ReactiveFunction<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>>) => void\n  onResult: (fn: (param: ApolloQueryResult<TResult>, context: OnResultContext) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError, context: OnErrorContext) => void) => {\n    off: () => void\n  }\n}\n\n/**\n * Use a query that does not require variables or options.\n * */\nexport function useQuery<TResult = any> (\n  document: DocumentParameter<TResult, undefined>\n): UseQueryReturn<TResult, Record<string, never>>\n\n/**\n * Use a query that has optional variables but not options\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>\n): UseQueryReturn<TResult, TVariables>\n\n/**\n * Use a query that has required variables but not options\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>\n): UseQueryReturn<TResult, TVariables>\n\n/**\n * Use a query that requires options but not variables.\n */\nexport function useQuery<TResult = any> (\n  document: DocumentParameter<TResult, undefined>,\n  variables: undefined | null,\n  options: OptionsParameter<TResult, Record<string, never>>,\n): UseQueryReturn<TResult, Record<string, never>>\n\n/**\n * Use a query that requires variables and options.\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables>,\n): UseQueryReturn<TResult, TVariables>\n\nexport function useQuery<\n  TResult,\n  TVariables extends OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options?: OptionsParameter<TResult, TVariables>,\n): UseQueryReturn<TResult, TVariables> {\n  return useQueryImpl<TResult, TVariables>(document, variables, options)\n}\n\nexport function useQueryImpl<\n  TResult,\n  TVariables extends OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables> = {},\n  lazy = false,\n): UseQueryReturn<TResult, TVariables> {\n  // Is on server?\n  const vm = getCurrentInstance() as CurrentInstance | null\n\n  const currentOptions = ref<UseQueryOptions<TResult, TVariables>>()\n\n  const documentRef = paramToRef(document)\n  const variablesRef = paramToRef(variables)\n  const optionsRef = paramToReactive(options)\n\n  // Result\n  /**\n   * Result from the query\n   */\n  const result = shallowRef<TResult | undefined>()\n  const resultEvent = useEventHook<[ApolloQueryResult<TResult>, OnResultContext]>()\n  const error = shallowRef<ApolloError | null>(null)\n  const errorEvent = useEventHook<[ApolloError, OnErrorContext]>()\n\n  // Loading\n\n  /**\n   * Indicates if a network request is pending\n   */\n  const loading = ref(false)\n  vm && trackQuery(loading)\n  const networkStatus = ref<number>()\n\n  // SSR\n  let firstResolve: (() => void) | undefined\n  let firstResolveTriggered = false\n  let firstReject: ((apolloError: ApolloError) => void) | undefined\n  let firstRejectError: undefined | ApolloError\n\n  const tryFirstResolve = () => {\n    firstResolveTriggered = true\n    if (firstResolve) firstResolve()\n  }\n\n  const tryFirstReject = (apolloError: ApolloError) => {\n    firstRejectError = apolloError\n    if (firstReject) firstReject(apolloError)\n  }\n\n  const resetFirstResolveReject = () => {\n    firstResolve = undefined\n    firstReject = undefined\n    firstResolveTriggered = false\n    firstRejectError = undefined\n  }\n\n  vm && onServerPrefetch?.(() => {\n    if (!isEnabled.value || (isServer && currentOptions.value?.prefetch === false)) return\n\n    return new Promise<void>((resolve, reject) => {\n      firstResolve = () => {\n        resetFirstResolveReject()\n        resolve()\n      }\n      firstReject = (apolloError: ApolloError) => {\n        resetFirstResolveReject()\n        reject(apolloError)\n      }\n\n      if (firstResolveTriggered) {\n        firstResolve()\n      } else if (firstRejectError) {\n        firstReject(firstRejectError)\n      }\n    }).finally(stop)\n  })\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  function getClient () {\n    return resolveClient(currentOptions.value?.clientId)\n  }\n\n  // Query\n\n  const query: Ref<ObservableQuery<TResult, TVariables> | null | undefined> = shallowRef()\n  let observer: ObservableSubscription | undefined\n  let started = false\n  let ignoreNextResult = false\n  let firstStart = true\n\n  /**\n   * Starts watching the query\n   */\n  function start () {\n    if (\n      started || !isEnabled.value ||\n      (isServer && currentOptions.value?.prefetch === false) ||\n      !currentDocument\n    ) {\n      tryFirstResolve()\n      return\n    }\n\n    // On server the watchers on document, variables and options are not triggered\n    if (isServer) {\n      applyDocument(documentRef.value)\n      applyVariables(variablesRef.value)\n      applyOptions(unref(optionsRef))\n    }\n\n    started = true\n    error.value = null\n    loading.value = true\n\n    const client = getClient()\n\n    query.value = client.watchQuery<TResult, TVariables>({\n      query: currentDocument,\n      variables: currentVariables ?? {} as TVariables,\n      ...currentOptions.value,\n      ...(isServer && currentOptions.value?.fetchPolicy !== 'no-cache')\n        ? {\n          fetchPolicy: 'network-only',\n        }\n        : {},\n    })\n\n    startQuerySubscription()\n\n    // Make the cache data available to the component immediately\n    // This prevents SSR hydration mismatches\n    if (!isServer && (firstStart || !currentOptions.value?.keepPreviousResult) && (currentOptions.value?.fetchPolicy !== 'no-cache' || currentOptions.value.notifyOnNetworkStatusChange)) {\n      const currentResult = query.value.getCurrentResult(false)\n\n      if (!currentResult.loading || currentResult.partial || currentOptions.value?.notifyOnNetworkStatusChange) {\n        onNextResult(currentResult)\n        ignoreNextResult = !currentResult.loading\n      } else if (currentResult.error) {\n        onError(currentResult.error)\n        ignoreNextResult = true\n      }\n    }\n\n    if (!isServer) {\n      for (const item of subscribeToMoreItems) {\n        addSubscribeToMore(item)\n      }\n    }\n\n    firstStart = false\n  }\n\n  function startQuerySubscription () {\n    if (observer && !observer.closed) return\n    if (!query.value) return\n\n    // Create subscription\n    ignoreNextResult = false\n    observer = query.value.subscribe({\n      next: onNextResult,\n      error: onError,\n    })\n  }\n\n  function getErrorPolicy () {\n    const client = resolveClient(currentOptions.value?.clientId)\n    return currentOptions.value?.errorPolicy || client.defaultOptions?.watchQuery?.errorPolicy\n  }\n\n  function onNextResult (queryResult: ApolloQueryResult<TResult>) {\n    if (ignoreNextResult) {\n      ignoreNextResult = false\n      return\n    }\n\n    // Remove any previous error that may still be present from the last fetch (so result handlers\n    // don't receive old errors that may not even be applicable anymore).\n    error.value = null\n\n    processNextResult(queryResult)\n\n    // When `errorPolicy` is `all`, `onError` will not get called and\n    // ApolloQueryResult.errors may be set at the same time as we get a result.\n    // The code is only relevant when `errorPolicy` is `all`, because for other situations it\n    // could hapen that next and error are called at the same time and then it will lead to multiple\n    // onError calls.\n    const errorPolicy = getErrorPolicy()\n    if (errorPolicy && errorPolicy === 'all' && !queryResult.error && queryResult.errors?.length) {\n      processError(resultErrorsToApolloError(queryResult.errors))\n    }\n\n    tryFirstResolve()\n  }\n\n  function processNextResult (queryResult: ApolloQueryResult<TResult>) {\n    result.value = queryResult.data && Object.keys(queryResult.data).length === 0 ? undefined : queryResult.data\n    loading.value = queryResult.loading\n    networkStatus.value = queryResult.networkStatus\n    // Wait for handlers to be registered\n    nextTick(() => {\n      resultEvent.trigger(queryResult, {\n        client: getClient(),\n      })\n    })\n  }\n\n  function onError (queryError: unknown) {\n    if (ignoreNextResult) {\n      ignoreNextResult = false\n      return\n    }\n\n    // any error should already be an ApolloError, but we make sure\n    const apolloError = toApolloError(queryError)\n    const errorPolicy = getErrorPolicy()\n\n    if (errorPolicy && errorPolicy !== 'none') {\n      processNextResult((query.value as ObservableQuery<TResult, TVariables>).getCurrentResult())\n    }\n    processError(apolloError)\n    tryFirstReject(apolloError)\n    // The observable closes the sub if an error occurs\n    resubscribeToQuery()\n  }\n\n  function processError (apolloError: ApolloError) {\n    error.value = apolloError\n    loading.value = false\n    networkStatus.value = 8\n    // Wait for handlers to be registered\n    nextTick(() => {\n      errorEvent.trigger(apolloError, {\n        client: getClient(),\n      })\n    })\n  }\n\n  function resubscribeToQuery () {\n    if (!query.value) return\n    const lastError = query.value.getLastError()\n    const lastResult = query.value.getLastResult()\n    query.value.resetLastResults()\n    startQuerySubscription()\n    Object.assign(query.value, { lastError, lastResult })\n  }\n\n  let onStopHandlers: Array<() => void> = []\n\n  /**\n   * Stop watching the query\n   */\n  function stop () {\n    tryFirstResolve()\n    if (!started) return\n    started = false\n    loading.value = false\n\n    onStopHandlers.forEach(handler => handler())\n    onStopHandlers = []\n\n    if (query.value) {\n      query.value.stopPolling()\n      query.value = null\n    }\n\n    if (observer) {\n      observer.unsubscribe()\n      observer = undefined\n    }\n  }\n\n  // Restart\n  let restarting = false\n  /**\n   * Queue a restart of the query (on next tick) if it is already active\n   */\n  function baseRestart () {\n    if (!started || restarting) return\n    restarting = true\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(() => {\n      if (started) {\n        stop()\n        start()\n      }\n      restarting = false\n    })\n  }\n\n  let debouncedRestart: typeof baseRestart\n  let isRestartDebounceSetup = false\n  function updateRestartFn () {\n    // On server, will be called before currentOptions is initialized\n    // @TODO investigate\n    if (!currentOptions.value) {\n      debouncedRestart = baseRestart\n    } else {\n      if (currentOptions.value?.throttle) {\n        debouncedRestart = throttle(currentOptions.value.throttle, baseRestart)\n      } else if (currentOptions.value?.debounce) {\n        debouncedRestart = debounce(currentOptions.value.debounce, baseRestart)\n      } else {\n        debouncedRestart = baseRestart\n      }\n      isRestartDebounceSetup = true\n    }\n  }\n\n  function restart () {\n    if (!started || restarting) return\n    if (!isRestartDebounceSetup) updateRestartFn()\n    debouncedRestart()\n  }\n\n  // Applying document\n  let currentDocument: DocumentNode | null | undefined = documentRef.value\n\n  // Enabled state\n\n  const forceDisabled = ref(lazy)\n  const enabledOption = computed(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled)\n  const isEnabled = computed(() => enabledOption.value && !forceDisabled.value && !!documentRef.value)\n\n  // Applying options first (in case it disables the query)\n  watch(() => unref(optionsRef), applyOptions, {\n    deep: true,\n    immediate: true,\n  })\n\n  function applyOptions (value: UseQueryOptions<TResult, TVariables>) {\n    if (currentOptions.value && (\n      currentOptions.value.throttle !== value.throttle ||\n      currentOptions.value.debounce !== value.debounce\n    )) {\n      updateRestartFn()\n    }\n    currentOptions.value = value\n    restart()\n  }\n\n  // Applying document\n  watch(documentRef, applyDocument)\n\n  function applyDocument (value: DocumentNode | null | undefined) {\n    currentDocument = value\n    restart()\n  }\n\n  // Applying variables\n  let currentVariables: TVariables | undefined\n  let currentVariablesSerialized: string\n  watch(() => {\n    if (isEnabled.value) {\n      return variablesRef.value\n    } else {\n      return undefined\n    }\n  }, applyVariables, {\n    deep: true,\n    immediate: true,\n  })\n\n  function applyVariables (value?: TVariables) {\n    const serialized = JSON.stringify([value, isEnabled.value])\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value\n      restart()\n    }\n    currentVariablesSerialized = serialized\n  }\n\n  // Refetch\n\n  function refetch (variables: TVariables | undefined = undefined) {\n    if (query.value) {\n      if (variables) {\n        currentVariables = variables\n      }\n      error.value = null\n      loading.value = true\n      return query.value.refetch(variables)\n        .then((refetchResult) => {\n          const currentResult = query.value?.getCurrentResult()\n          currentResult && processNextResult(currentResult)\n          return refetchResult\n        })\n    }\n  }\n\n  // Fetch more\n\n  function fetchMore (options: FetchMoreQueryOptions<TVariables, TResult> & FetchMoreOptions<TResult, TVariables>) {\n    if (query.value) {\n      error.value = null\n      loading.value = true\n      return query.value.fetchMore(options)\n        .then((fetchMoreResult) => {\n          const currentResult = query.value?.getCurrentResult()\n          currentResult && processNextResult(currentResult)\n          return fetchMoreResult\n        })\n    }\n  }\n\n  // Subscribe to more\n\n  const subscribeToMoreItems: SubscribeToMoreItem[] = []\n\n  function subscribeToMore<\n    TSubscriptionVariables = OperationVariables,\n    TSubscriptionData = TResult\n  > (\n    options: SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData> |\n    Ref<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>> |\n    ReactiveFunction<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>>,\n  ) {\n    if (isServer) return\n    const optionsRef = paramToRef(options)\n    watch(optionsRef, (value, oldValue, onCleanup) => {\n      const index = subscribeToMoreItems.findIndex(item => item.options === oldValue)\n      if (index !== -1) {\n        subscribeToMoreItems.splice(index, 1)\n      }\n      const item: SubscribeToMoreItem = {\n        options: value,\n        unsubscribeFns: [],\n      }\n      subscribeToMoreItems.push(item)\n\n      addSubscribeToMore(item)\n\n      onCleanup(() => {\n        item.unsubscribeFns.forEach(fn => fn())\n        item.unsubscribeFns = []\n      })\n    }, {\n      immediate: true,\n    })\n  }\n\n  function addSubscribeToMore (item: SubscribeToMoreItem) {\n    if (!started) return\n    if (!query.value) {\n      throw new Error('Query is not defined')\n    }\n    const unsubscribe = query.value.subscribeToMore(item.options)\n    onStopHandlers.push(unsubscribe)\n    item.unsubscribeFns.push(unsubscribe)\n  }\n\n  // Auto start & stop\n\n  watch(isEnabled, value => {\n    if (value) {\n      nextTick(() => {\n        start()\n      })\n    } else {\n      stop()\n    }\n  })\n\n  if (isEnabled.value) {\n    start()\n  }\n\n  // Teardown\n  vm && onBeforeUnmount(() => {\n    stop()\n    subscribeToMoreItems.length = 0\n  })\n\n  return {\n    result,\n    loading,\n    networkStatus,\n    error,\n    start,\n    stop,\n    restart,\n    forceDisabled,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    query,\n    refetch,\n    fetchMore,\n    subscribeToMore,\n    onResult: resultEvent.on,\n    onError: errorEvent.on,\n  }\n}\n","import { hasInjectionContext, inject } from 'vue-demi'\nimport { ApolloClient } from '@apollo/client/core/index.js'\n\nexport const DefaultApolloClient = Symbol('default-apollo-client')\nexport const ApolloClients = Symbol('apollo-clients')\n\ntype ClientId = string\ntype ClientDict<T> = Record<ClientId, ApolloClient<T>>\n\ntype ResolveClient<TCacheShape, TReturn = ApolloClient<TCacheShape>> = (clientId?: ClientId) => TReturn\ntype NullableApolloClient<TCacheShape> = ApolloClient<TCacheShape> | undefined\n\nexport interface UseApolloClientReturn<TCacheShape> {\n  resolveClient: ResolveClient<TCacheShape>\n  readonly client: ApolloClient<TCacheShape>\n}\n\nfunction resolveDefaultClient<T> (providedApolloClients: ClientDict<T> | null, providedApolloClient: ApolloClient<T> | null): NullableApolloClient<T> {\n  const resolvedClient = providedApolloClients\n    ? providedApolloClients.default\n    : (providedApolloClient ?? undefined)\n  return resolvedClient\n}\n\nfunction resolveClientWithId<T> (providedApolloClients: ClientDict<T> | null, clientId: ClientId): NullableApolloClient<T> {\n  if (!providedApolloClients) {\n    throw new Error(`No apolloClients injection found, tried to resolve '${clientId}' clientId`)\n  }\n  return providedApolloClients[clientId]\n}\n\nexport function useApolloClient<TCacheShape = any> (clientId?: ClientId): UseApolloClientReturn<TCacheShape> {\n  let resolveImpl: ResolveClient<TCacheShape, NullableApolloClient<TCacheShape>>\n\n  // Save current client in current closure scope\n  const savedCurrentClients = currentApolloClients\n\n  if (!hasInjectionContext()) {\n    resolveImpl = (id?: ClientId) => {\n      if (id) {\n        return resolveClientWithId(savedCurrentClients, id)\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default)\n    }\n  } else {\n    const providedApolloClients: ClientDict<TCacheShape> | null = inject(ApolloClients, null)\n    const providedApolloClient: ApolloClient<TCacheShape> | null = inject(DefaultApolloClient, null)\n\n    resolveImpl = (id?: ClientId) => {\n      if (id) {\n        const client = resolveClientWithId(providedApolloClients, id)\n        if (client) {\n          return client\n        }\n        return resolveClientWithId(savedCurrentClients, id)\n      }\n      const client = resolveDefaultClient(providedApolloClients, providedApolloClient)\n      if (client) {\n        return client\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default)\n    }\n  }\n\n  function resolveClient (id: ClientId | undefined = clientId) {\n    const client = resolveImpl(id)\n    if (!client) {\n      throw new Error(\n        `Apollo client with id ${\n          id ?? 'default'\n        } not found. Use an app.runWithContext() or provideApolloClient() if you are outside of a component setup.`,\n      )\n    }\n    return client\n  }\n\n  return {\n    resolveClient,\n    get client () {\n      return resolveClient()\n    },\n  }\n}\n\nlet currentApolloClients: ClientDict<any> = {}\n\nexport function provideApolloClient<TCacheShape = any> (client: ApolloClient<TCacheShape>) {\n  currentApolloClients = {\n    default: client,\n  }\n  return function <TFnResult = any> (fn: () => TFnResult) {\n    const result = fn()\n    currentApolloClients = {}\n    return result\n  }\n}\n\nexport function provideApolloClients<TCacheShape = any> (clients: ClientDict<TCacheShape>) {\n  currentApolloClients = clients\n  return function <TFnResult = any> (fn: () => TFnResult) {\n    const result = fn()\n    currentApolloClients = {}\n    return result\n  }\n}\n","import { Ref, isRef, computed, ref } from 'vue-demi'\nimport { ReactiveFunction } from './ReactiveFunction'\n\nexport function paramToRef<T> (param: T | Ref<T> | ReactiveFunction<T>): Ref<T> {\n  if (isRef(param)) {\n    return param\n  } else if (typeof param === 'function') {\n    return computed(param as ReactiveFunction<T>)\n  } else {\n    return ref(param) as Ref<T>\n  }\n}\n","import { Ref, isRef, reactive, computed } from 'vue-demi'\nimport { ReactiveFunction } from './ReactiveFunction'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype TObject = object\n\nexport function paramToReactive<T extends TObject> (param: T | Ref<T> | ReactiveFunction<T>): T | Ref<T> {\n  if (isRef(param)) {\n    return param\n  } else if (typeof param === 'function') {\n    return computed(param as ReactiveFunction<T>)\n  } else if (param) {\n    return reactive(param) as T\n  } else {\n    return param\n  }\n}\n","export function useEventHook<TParams extends any[] = any[]> () {\n  const fns: Array<(...params: TParams) => void> = []\n\n  function on (fn: (...params: TParams) => void) {\n    fns.push(fn)\n    return {\n      off: () => off(fn),\n    }\n  }\n\n  function off (fn: (...params: TParams) => void) {\n    const index = fns.indexOf(fn)\n    if (index !== -1) {\n      fns.splice(index, 1)\n    }\n  }\n\n  function trigger (...params: TParams) {\n    for (const fn of fns) {\n      fn(...params)\n    }\n  }\n\n  function getCount () {\n    return fns.length\n  }\n\n  return {\n    on,\n    off,\n    trigger,\n    getCount,\n  }\n}\n","import { Ref, watch, onUnmounted, ref, getCurrentInstance, onBeforeUnmount } from 'vue-demi'\nimport { isServer } from './env.js'\n\nexport interface LoadingTracking {\n  queries: Ref<number>\n  mutations: Ref<number>\n  subscriptions: Ref<number>\n}\n\nexport interface AppLoadingTracking extends LoadingTracking {\n  components: Map<any, LoadingTracking>\n}\n\nexport const globalTracking: AppLoadingTracking = {\n  queries: ref(0),\n  mutations: ref(0),\n  subscriptions: ref(0),\n  components: new Map(),\n}\n\nexport function getCurrentTracking () {\n  const vm = getCurrentInstance()\n  if (!vm) {\n    return {}\n  }\n\n  let tracking: LoadingTracking\n\n  if (!globalTracking.components.has(vm)) {\n    // Add per-component tracking\n    globalTracking.components.set(vm, tracking = {\n      queries: ref(0),\n      mutations: ref(0),\n      subscriptions: ref(0),\n    })\n    // Cleanup\n    onUnmounted(() => {\n      globalTracking.components.delete(vm)\n    })\n  } else {\n    tracking = globalTracking.components.get(vm) as LoadingTracking\n  }\n\n  return {\n    tracking,\n  }\n}\n\nfunction track (loading: Ref<boolean>, type: keyof LoadingTracking) {\n  if (isServer) return\n\n  const { tracking } = getCurrentTracking()\n\n  watch(loading, (value, oldValue) => {\n    if (oldValue != null && value !== oldValue) {\n      const mod = value ? 1 : -1\n      if (tracking) tracking[type].value += mod\n      globalTracking[type].value += mod\n    }\n  }, {\n    immediate: true,\n  })\n\n  onBeforeUnmount(() => {\n    if (loading.value) {\n      if (tracking) tracking[type].value--\n      globalTracking[type].value--\n    }\n  })\n}\n\nexport function trackQuery (loading: Ref<boolean>) {\n  track(loading, 'queries')\n}\n\nexport function trackMutation (loading: Ref<boolean>) {\n  track(loading, 'mutations')\n}\n\nexport function trackSubscription (loading: Ref<boolean>) {\n  track(loading, 'subscriptions')\n}\n","export const isServer = typeof window === 'undefined'\n","import { ApolloError, isApolloError } from '@apollo/client/core/index.js'\nimport { GraphQLErrors } from '@apollo/client/errors/index.js'\n\nexport function toApolloError (error: unknown): ApolloError {\n  if (!(error instanceof Error)) {\n    return new ApolloError({\n      networkError: Object.assign(new Error(), { originalError: error }),\n      errorMessage: String(error),\n    })\n  }\n\n  if (isApolloError(error)) {\n    return error\n  }\n\n  return new ApolloError({ networkError: error, errorMessage: error.message })\n}\n\nexport function resultErrorsToApolloError (errors: GraphQLErrors): ApolloError {\n  return new ApolloError({\n    graphQLErrors: errors,\n    errorMessage: `GraphQL response contains errors: ${errors.map((e: any) => e.message).join(' | ')}`,\n  })\n}\n","import { DocumentNode } from 'graphql'\nimport { isRef } from 'vue-demi'\nimport { useQueryImpl, DocumentParameter, VariablesParameter, OptionsParameter, UseQueryOptions, UseQueryReturn } from './useQuery'\nimport type { OperationVariables } from '@apollo/client/core'\nimport { isServer } from './util/env.js'\n\nexport interface UseLazyQueryReturn<TResult, TVariables extends OperationVariables> extends UseQueryReturn<TResult, TVariables> {\n  /**\n   * Activate the query and starts loading.\n   * @param document Override document\n   * @param variables Override variables\n   * @param options Override options\n   * @returns Returns false if the query is already active, otherwise the next result of the query.\n   */\n  load: (document?: DocumentNode | null, variables?: TVariables | null, options?: UseQueryOptions | null) => false | Promise<TResult>\n}\n\nexport function useLazyQuery<\n  TResult = any,\n  TVariables extends Record<string, unknown> = any,\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options?: OptionsParameter<TResult, TVariables>,\n): UseLazyQueryReturn<TResult, TVariables> {\n  const query = useQueryImpl<TResult, TVariables>(document, variables, options, true)\n\n  function load (\n    document?: DocumentNode | null,\n    variables?: TVariables | null,\n    options?: UseQueryOptions | null,\n  ) {\n    if (document) {\n      query.document.value = document\n    }\n    if (variables) {\n      query.variables.value = variables\n    }\n    if (options) {\n      Object.assign(isRef(query.options) ? query.options.value : query.options, options)\n    }\n    const isFirstRun = query.forceDisabled.value\n    if (isFirstRun) {\n      query.forceDisabled.value = false\n\n      // If SSR, we need to start the query manually since `watch` on `isEnabled` in `useQueryImpl` won't be called.\n      if (isServer) {\n        query.start()\n      }\n\n      return new Promise<TResult>((resolve, reject) => {\n        const { off: offResult } = query.onResult((result) => {\n          if (!result.loading) {\n            resolve(result.data)\n            offResult()\n            offError()\n          }\n        })\n        const { off: offError } = query.onError((error) => {\n          reject(error)\n          offResult()\n          offError()\n        })\n      })\n    } else {\n      return false\n    }\n  }\n\n  return {\n    ...query,\n    load,\n  }\n}\n","import { DocumentNode } from 'graphql'\nimport { MutationOptions, OperationVariables, FetchResult, TypedDocumentNode, ApolloError, ApolloClient } from '@apollo/client/core/index.js'\nimport { ref, onBeforeUnmount, isRef, Ref, getCurrentInstance, shallowRef } from 'vue-demi'\nimport { useApolloClient } from './useApolloClient'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { useEventHook } from './util/useEventHook'\nimport { trackMutation } from './util/loadingTracking'\nimport { toApolloError } from './util/toApolloError'\n\n/**\n * `useMutation` options for mutations that don't require `variables`.\n */\nexport interface UseMutationOptions<\n  TResult = any,\n  TVariables = OperationVariables\n> extends Omit<MutationOptions<TResult, TVariables>, 'mutation'> {\n  clientId?: string\n  throws?: 'auto' | 'always' | 'never'\n}\n\ntype DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\ntype OptionsParameter<TResult, TVariables> = UseMutationOptions<TResult, TVariables> | Ref<UseMutationOptions<TResult, TVariables>> | ReactiveFunction<UseMutationOptions<TResult, TVariables>>\n\nexport type MutateOverrideOptions<TResult> = Pick<UseMutationOptions<TResult, OperationVariables>, 'update' | 'optimisticResponse' | 'context' | 'updateQueries' | 'refetchQueries' | 'awaitRefetchQueries' | 'errorPolicy' | 'fetchPolicy' | 'clientId'>\nexport type MutateResult<TResult> = Promise<FetchResult<TResult, Record<string, any>, Record<string, any>> | null>\nexport type MutateFunction<TResult, TVariables> = (variables?: TVariables | null, overrideOptions?: MutateOverrideOptions<TResult>) => MutateResult<TResult>\n\nexport interface OnDoneContext {\n  client: ApolloClient<any>\n}\n\nexport interface OnErrorContext {\n  client: ApolloClient<any>\n}\n\nexport interface UseMutationReturn<TResult, TVariables> {\n  mutate: MutateFunction<TResult, TVariables>\n  loading: Ref<boolean>\n  error: Ref<ApolloError | null>\n  called: Ref<boolean>\n  onDone: (fn: (param: FetchResult<TResult, Record<string, any>, Record<string, any>>, context: OnDoneContext) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError, context: OnErrorContext) => void) => {\n    off: () => void\n  }\n}\n\nexport function useMutation<\n  TResult = any,\n  TVariables extends OperationVariables = OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  options: OptionsParameter<TResult, TVariables> = {},\n): UseMutationReturn<TResult, TVariables> {\n  const vm = getCurrentInstance()\n  const loading = ref<boolean>(false)\n  vm && trackMutation(loading)\n  const error = shallowRef<ApolloError | null>(null)\n  const called = ref<boolean>(false)\n\n  const doneEvent = useEventHook<[FetchResult<TResult, Record<string, any>, Record<string, any>>, OnDoneContext]>()\n  const errorEvent = useEventHook<[ApolloError, OnErrorContext]>()\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  async function mutate (variables?: TVariables | null, overrideOptions: Omit<UseMutationOptions<TResult, TVariables>, 'variables'> = {}) {\n    let currentDocument: DocumentNode\n    if (typeof document === 'function') {\n      currentDocument = document()\n    } else if (isRef(document)) {\n      currentDocument = document.value\n    } else {\n      currentDocument = document\n    }\n\n    let currentOptions: UseMutationOptions<TResult, TVariables>\n    if (typeof options === 'function') {\n      currentOptions = options()\n    } else if (isRef(options)) {\n      currentOptions = options.value\n    } else {\n      currentOptions = options\n    }\n    const client = resolveClient(currentOptions.clientId)\n    error.value = null\n    loading.value = true\n    called.value = true\n    try {\n      const result = await client.mutate<TResult, TVariables>({\n        mutation: currentDocument,\n        ...currentOptions,\n        ...overrideOptions,\n        variables: (variables ?? currentOptions.variables)\n          ? {\n            ...(currentOptions.variables as TVariables),\n            ...(variables as TVariables),\n          }\n          : undefined,\n      })\n      loading.value = false\n      doneEvent.trigger(result, {\n        client,\n      })\n      return result\n    } catch (e) {\n      const apolloError = toApolloError(e)\n      error.value = apolloError\n      loading.value = false\n      errorEvent.trigger(apolloError, {\n        client,\n      })\n      if (currentOptions.throws === 'always' || (currentOptions.throws !== 'never' && !errorEvent.getCount())) {\n        throw apolloError\n      }\n    }\n    return null\n  }\n\n  vm && onBeforeUnmount(() => {\n    loading.value = false\n  })\n\n  return {\n    mutate,\n    loading,\n    error,\n    called,\n    onDone: doneEvent.on,\n    onError: errorEvent.on,\n  }\n}\n","import { DocumentNode } from 'graphql'\nimport {\n  Ref,\n  ref,\n  watch,\n  isRef,\n  computed,\n  getCurrentInstance,\n  onBeforeUnmount,\n  nextTick,\n  shallowRef,\n} from 'vue-demi'\nimport type {\n  OperationVariables,\n  SubscriptionOptions,\n  FetchResult,\n  Observable,\n  ObservableSubscription,\n  TypedDocumentNode,\n  ApolloError,\n  ApolloClient,\n} from '@apollo/client/core/index.js'\nimport { throttle, debounce } from 'throttle-debounce'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { paramToRef } from './util/paramToRef'\nimport { paramToReactive } from './util/paramToReactive'\nimport { useApolloClient } from './useApolloClient'\nimport { useEventHook } from './util/useEventHook'\nimport { trackSubscription } from './util/loadingTracking'\nimport type { CurrentInstance } from './util/types'\nimport { toApolloError } from './util/toApolloError'\nimport { isServer } from './util/env'\n\nexport interface UseSubscriptionOptions <\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TResult = any,\n  TVariables = OperationVariables\n> extends Omit<SubscriptionOptions<TVariables>, 'query' | 'variables'> {\n  clientId?: string\n  enabled?: boolean | Ref<boolean>\n  throttle?: number\n  debounce?: number\n}\n\ntype DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\ntype VariablesParameter<TVariables> = TVariables | Ref<TVariables> | ReactiveFunction<TVariables>\ntype OptionsParameter<TResult, TVariables> = UseSubscriptionOptions<TResult, TVariables> | Ref<UseSubscriptionOptions<TResult, TVariables>> | ReactiveFunction<UseSubscriptionOptions<TResult, TVariables>>\n\nexport interface OnResultContext {\n  client: ApolloClient<any>\n}\n\nexport interface OnErrorContext {\n  client: ApolloClient<any>\n}\n\nexport interface UseSubscriptionReturn<TResult, TVariables> {\n  result: Ref<TResult | null | undefined>\n  loading: Ref<boolean>\n  error: Ref<ApolloError | null>\n  start: () => void\n  stop: () => void\n  restart: () => void\n  document: Ref<DocumentNode>\n  variables: Ref<TVariables | undefined>\n  options: UseSubscriptionOptions<TResult, TVariables> | Ref<UseSubscriptionOptions<TResult, TVariables>>\n  subscription: Ref<Observable<FetchResult<TResult, Record<string, any>, Record<string, any>>> | null>\n  onResult: (fn: (param: FetchResult<TResult, Record<string, any>, Record<string, any>>, context: OnResultContext) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError, context: OnErrorContext) => void) => {\n    off: () => void\n  }\n}\n\n/**\n * Use a subscription that does not require variables or options.\n * */\nexport function useSubscription<TResult = any> (\n  document: DocumentParameter<TResult, undefined>\n): UseSubscriptionReturn<TResult, undefined>\n\n/**\n * Use a subscription that requires options but not variables.\n */\nexport function useSubscription<TResult = any> (\n  document: DocumentParameter<TResult, undefined>,\n  variables: undefined | null,\n  options: OptionsParameter<TResult, null>\n): UseSubscriptionReturn<TResult, null>\n\n/**\n * Use a subscription that requires variables.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>\n): UseSubscriptionReturn<TResult, TVariables>\n\n/**\n * Use a subscription that has optional variables.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n): UseSubscriptionReturn<TResult, TVariables>\n\n/**\n * Use a subscription that requires variables and options.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables>\n): UseSubscriptionReturn<TResult, TVariables>\n\nexport function useSubscription <\n  TResult,\n  TVariables extends Record<string, unknown>\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables> | undefined = undefined,\n  options: OptionsParameter<TResult, TVariables> = {},\n): UseSubscriptionReturn<TResult, TVariables> {\n  // Is on server?\n  const vm = getCurrentInstance() as CurrentInstance | null\n\n  const documentRef = paramToRef(document)\n  const variablesRef = paramToRef(variables)\n  const optionsRef = paramToReactive(options)\n\n  const result = shallowRef<TResult | null | undefined>()\n  const resultEvent = useEventHook<[FetchResult<TResult>, OnResultContext]>()\n  const error = shallowRef<ApolloError | null>(null)\n  const errorEvent = useEventHook<[ApolloError, OnErrorContext]>()\n\n  const loading = ref(false)\n  vm && trackSubscription(loading)\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  const subscription: Ref<Observable<FetchResult<TResult>> | null> = ref(null)\n  let observer: ObservableSubscription | null = null\n  let started = false\n\n  function getClient () {\n    return resolveClient(currentOptions.value?.clientId)\n  }\n\n  function start () {\n    if (started || !isEnabled.value || isServer) return\n    started = true\n    loading.value = true\n\n    const client = getClient()\n\n    subscription.value = client.subscribe<TResult, TVariables>({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value,\n    })\n\n    observer = subscription.value.subscribe({\n      next: onNextResult,\n      error: onError,\n    })\n  }\n\n  function onNextResult (fetchResult: FetchResult<TResult>) {\n    result.value = fetchResult.data\n    loading.value = false\n    resultEvent.trigger(fetchResult, {\n      client: getClient(),\n    })\n  }\n\n  function onError (fetchError: unknown) {\n    const apolloError = toApolloError(fetchError)\n\n    error.value = apolloError\n    loading.value = false\n    errorEvent.trigger(apolloError, {\n      client: getClient(),\n    })\n  }\n\n  function stop () {\n    if (!started) return\n    started = false\n    loading.value = false\n\n    if (subscription.value) {\n      subscription.value = null\n    }\n\n    if (observer) {\n      observer.unsubscribe()\n      observer = null\n    }\n  }\n\n  // Restart\n  let restarting = false\n  /**\n   * Queue a restart of the query (on next tick) if it is already active\n   */\n  function baseRestart () {\n    if (!started || restarting) return\n    restarting = true\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(() => {\n      if (started) {\n        stop()\n        start()\n      }\n      restarting = false\n    })\n  }\n\n  let debouncedRestart: typeof baseRestart\n  function updateRestartFn () {\n    if (currentOptions.value?.throttle) {\n      debouncedRestart = throttle(currentOptions.value.throttle, baseRestart)\n    } else if (currentOptions.value?.debounce) {\n      debouncedRestart = debounce(currentOptions.value.debounce, baseRestart)\n    } else {\n      debouncedRestart = baseRestart\n    }\n  }\n\n  function restart () {\n    if (!debouncedRestart) updateRestartFn()\n    debouncedRestart()\n  }\n\n  // Applying options\n  const currentOptions = ref<UseSubscriptionOptions<TResult, TVariables>>()\n  watch(() => isRef(optionsRef) ? optionsRef.value : optionsRef, value => {\n    if (currentOptions.value && (\n      currentOptions.value.throttle !== value.throttle ||\n      currentOptions.value.debounce !== value.debounce\n    )) {\n      updateRestartFn()\n    }\n    currentOptions.value = value\n    restart()\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Applying document\n  let currentDocument: DocumentNode\n  watch(documentRef, value => {\n    currentDocument = value\n    restart()\n  }, {\n    immediate: true,\n  })\n\n  // Applying variables\n  let currentVariables: TVariables | undefined\n  let currentVariablesSerialized: string\n  watch(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value)\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value\n      restart()\n    }\n    currentVariablesSerialized = serialized\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Internal enabled returned to user\n  // @TODO Doesn't fully work yet, need to initialize with option\n  // const enabled = ref<boolean>()\n  const enabledOption = computed(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled)\n  // const isEnabled = computed(() => !!((typeof enabled.value === 'boolean' && enabled.value) && enabledOption.value))\n  const isEnabled = enabledOption\n\n  // watch(enabled, value => {\n  //   if (value == null) {\n  //     enabled.value = enabledOption.value\n  //   }\n  // })\n\n  // Auto start & stop\n  watch(isEnabled, value => {\n    if (value) {\n      start()\n    } else {\n      stop()\n    }\n  }, {\n    immediate: true,\n  })\n\n  // Teardown\n  vm && onBeforeUnmount(stop)\n\n  return {\n    result,\n    loading,\n    error,\n    // @TODO doesn't fully work yet\n    // enabled,\n    start,\n    stop,\n    restart,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    subscription,\n    onResult: resultEvent.on,\n    onError: errorEvent.on,\n  }\n}\n","import { Ref, computed } from 'vue-demi'\nimport { ExtractSingleKey } from './util/ExtractSingleKey'\nimport type { DeepNonNullable, DeepRequired } from 'ts-essentials'\n\nexport type UseResultReturn<T> = Readonly<Ref<Readonly<T>>>\n\n/**\n * Resolve a `result`, returning either the first key of the `result` if there\n * is only one, or the `result` itself. The `value` of the ref will be\n * `undefined` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const user = useResult(result)\n * // user is `undefined` until the query resolves\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @returns Readonly ref with `undefined` or the resolved `result`.\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<TResult, TResultKey extends keyof NonNullable<TResult> = keyof NonNullable<TResult>> (\n  result: Ref<TResult>\n): UseResultReturn<undefined | ExtractSingleKey<NonNullable<TResult>, TResultKey>>\n\n/**\n * Resolve a `result`, returning either the first key of the `result` if there\n * is only one, or the `result` itself. The `value` of the ref will be\n * `defaultValue` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const profile = useResult(result, {})\n * // profile is `{}` until the query resolves\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @param  {TDefaultValue} defaultValue The default return value before `result` is resolved.\n * @returns Readonly ref with the `defaultValue` or the resolved `result`.\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<TResult, TDefaultValue, TResultKey extends keyof NonNullable<TResult> = keyof NonNullable<TResult>> (\n  result: Ref<TResult>,\n  defaultValue: TDefaultValue\n): UseResultReturn<TDefaultValue | ExtractSingleKey<NonNullable<TResult>, TResultKey>>\n\n/**\n * Resolve a `result`, returning the `result` mapped with the `pick` function.\n * The `value` of the ref will be `defaultValue` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const comments = useResult(result, undefined, (data) => data.comments)\n * // user is `undefined`, then resolves to the result's `comments`\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @param  {TDefaultValue} defaultValue The default return value before `result` is resolved.\n * @param  {(data:TResult)=>TReturnValue} pick The function that receives `result` and maps a return value from it.\n * @returns Readonly ref with the `defaultValue` or the resolved and `pick`-mapped `result`\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<\n  TResult,\n  TDefaultValue,\n  TReturnValue,\n> (\n  result: Ref<TResult>,\n  defaultValue: TDefaultValue | undefined,\n  pick: (data: DeepRequired<DeepNonNullable<TResult>>) => TReturnValue\n): UseResultReturn<TDefaultValue | TReturnValue>\n\n/**\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<\n  TResult,\n  TDefaultValue,\n  TReturnValue,\n> (\n  result: Ref<TResult>,\n  defaultValue?: TDefaultValue,\n  pick?: (data: DeepRequired<DeepNonNullable<TResult>>) => TReturnValue,\n): UseResultReturn<TResult | TResult[keyof TResult] | TDefaultValue | TReturnValue | undefined> {\n  console.warn(`'useResult' is deprecated and will be removed soon. Please use 'computed' instead.\nBefore:\nconst items = useResult(result, [], data => data.someField.myItems)\nAfter:\nconst items = computed(() => result.value?.someField.myItems ?? [])`)\n  return computed(() => {\n    const value = result.value\n    if (value) {\n      if (pick) {\n        try {\n          return pick(value as DeepRequired<DeepNonNullable<TResult>>)\n        } catch (e) {\n          // Silent error\n        }\n      } else {\n        const keys = Object.keys(value)\n        if (keys.length === 1) {\n          // Automatically take the only key in result data\n          return value[keys[0] as keyof TResult]\n        } else {\n          // Return entire result data\n          return value\n        }\n      }\n    }\n    return defaultValue\n  })\n}\n","import { getCurrentTracking, globalTracking } from './util/loadingTracking'\nimport { computed } from 'vue-demi'\n\nexport function useQueryLoading () {\n  const { tracking } = getCurrentTracking()\n  if (!tracking) throw new Error('useQueryLoading must be called inside a setup function.')\n  return computed(() => tracking.queries.value > 0)\n}\n\nexport function useMutationLoading () {\n  const { tracking } = getCurrentTracking()\n  if (!tracking) throw new Error('useMutationLoading must be called inside a setup function.')\n  return computed(() => tracking.mutations.value > 0)\n}\n\nexport function useSubscriptionLoading () {\n  const { tracking } = getCurrentTracking()\n  if (!tracking) throw new Error('useSubscriptionLoading must be called inside a setup function.')\n  return computed(() => tracking.subscriptions.value > 0)\n}\n\nexport function useGlobalQueryLoading () {\n  return computed(() => globalTracking.queries.value > 0)\n}\n\nexport function useGlobalMutationLoading () {\n  return computed(() => globalTracking.mutations.value > 0)\n}\n\nexport function useGlobalSubscriptionLoading () {\n  return computed(() => globalTracking.subscriptions.value > 0)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}